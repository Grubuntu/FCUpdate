# FreeCAD Update Checker
#
# Copyright (C) 2025 Grubuntu
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA

# Attribution:
# http://forum.freecadweb.org/
# http://www.freecadweb.org/wiki/index.php?title=Code_snippets
#

import os
from pathlib import Path
from PySide import QtCore, QtGui, QtWidgets
from PySide.QtWidgets import QMessageBox
translate = App.Qt.translate

# Chemin vers le dossier utilisateur de FreeCAD
mod_path = Path(os.getenv('APPDATA')) / "FreeCAD" / "Mod" / "CheckUpdate"
mod_path.mkdir(parents=True, exist_ok=True)

# === Contenu du fichier InitGui.py ===
init_gui_content = '''\
from PySide import QtGui
import FreeCAD as App

def runStartupMacros(name):
    if name != "NoneWorkbench":
        Gui.getMainWindow().workbenchActivated.disconnect(runStartupMacros)
        import CheckUpdate
        CheckUpdate.run()

import __main__
__main__.runStartupMacros = runStartupMacros

Gui.getMainWindow().workbenchActivated.connect(runStartupMacros)
'''

# === Contenu initial de CheckUpdate.py ===
check_update_content = '''\
CHECKUPDATEVERSION = "1.0"

import os
import re
import sys
import json
import time
import webbrowser
import requests
from datetime import datetime, timedelta
from pathlib import Path
from PySide import QtGui, QtCore, QtWidgets
import FreeCAD as App
import FreeCADGui as Gui
from functools import partial
from PySide.QtCore import QTimer, QPoint
from PySide.QtWidgets import QToolTip

# === CONFIGURATION ===

URL_STABLE = "https://api.github.com/repos/FreeCAD/FreeCAD-Bundle/releases/latest"
URL_WEEKLY = "https://api.github.com/repos/FreeCAD/FreeCAD-Bundle/releases/tags/weekly-builds"

CHECK_INTERVAL = timedelta(hours=1)

def get_freecad_config_dir():
    if sys.platform == "win32":
        return os.path.join(os.getenv("APPDATA"), "FreeCAD")
    elif sys.platform == "darwin":
        return os.path.join(os.path.expanduser("~"), "Library", "Preferences", "FreeCAD")
    else:
        return os.path.join(os.path.expanduser("~"), ".config", "FreeCAD")

CONFIG_DIR = get_freecad_config_dir()
CONFIG_FILE = os.path.join(CONFIG_DIR, "FCUpdate.cfg")
os.makedirs(CONFIG_DIR, exist_ok=True)

ICON_UP_TO_DATE = QtGui.QApplication.style().standardIcon(QtGui.QStyle.SP_DialogApplyButton)
ICON_UPDATE_AVAILABLE = QtGui.QApplication.style().standardIcon(QtGui.QStyle.SP_BrowserReload)
ICON_ERROR = QtGui.QApplication.style().standardIcon(QtGui.QStyle.SP_MessageBoxWarning)

# === FONCTIONS VERSIONS ===

def get_freecad_version_type():
    version_info = App.Version()

    if len(version_info) < 6:
        return "FreeCAD (Unknown version)"

    major, minor, patch = version_info[0:3]
    build_info = version_info[3]
    repo_url = version_info[4]
    git_branch = version_info[6] if len(version_info) > 6 else ""
    git_tag = version_info[7] if len(version_info) > 7 else ""

    version_text = str(App.Version())

    # Détection stable
    if "detached at" in git_branch:
        if major == "1" and minor == "0":
            return "FreeCAD 1.0.x Stable"
        return "FreeCAD Stable Release"

    # Détection weekly
    if "main" in repo_url.lower():
        return "FreeCAD Weekly Build"

    return "FreeCAD (Version personnalisée ou inconnue)"

# pour debug
# def get_freecad_version_label():
    # version_type = get_freecad_version_type()
    # version_full = ".".join(App.Version()[0:3])
    # return f"{version_type} ({version_full})"

def get_local_build_number():
    build_str = App.Version()[3]
    match = re.search(r'(\d+)', build_str)
    return int(match.group(1)) if match else None

def get_remote_build_number():
    try:
        with requests.get(URL_WEEKLY, timeout=10) as r:
            r.raise_for_status()
            html = r.text
            match = re.search(r"FreeCAD_weekly-builds-(\d+)-", html)
            return int(match.group(1)) if match else None
    except Exception as e:
        App.Console.PrintError(f"Erreur récupération version weekly en ligne : {e}\\n")
        return None
        
def get_remote_stable_version():
    try:
        r = requests.get(URL_STABLE, timeout=10)
        r.raise_for_status()
        data = r.json()
        tag = data.get("tag_name", "")
        match = re.match(r"v?(\d+\.\d+\.\d+)", tag)
        return match.group(1) if match else None
    except Exception as e:
        App.Console.PrintError(f"Erreur récupération version stable en ligne : {e}\\n")
        return None

# === CACHE TEMPOREL ===

def read_cache():
    if not os.path.exists(CONFIG_FILE):
        return None, []
    try:
        with open(CONFIG_FILE, "r") as f:
            data = json.load(f)
            last_check = datetime.fromisoformat(data.get("last_check", ""))
            results = data.get("results_cache", [])
            return last_check, results
    except Exception:
        return None, []

def write_cache(last_check, results_cache):
    with open(CONFIG_FILE, "w") as f:
        json.dump({
            "last_check": last_check.isoformat() if last_check else "",
            "results_cache": results_cache
        }, f, indent=4)

# === BOUTON / INTERFACE ===

def show_update_tooltip(widget, message, delay_ms=20000):
    """Affiche un tooltip centré sur le widget donné après un délai."""
    if not widget:
        print("Erreur : widget est None")
        return

    def show():
        pos = widget.mapToGlobal(widget.rect().center())
        QToolTip.showText(pos, message, widget)

    QTimer.singleShot(delay_ms, show)

def add_button(icon, tooltip):
    """Ajoute un QToolButton dans la barre d'outils (et le retourne pour interaction)."""
    mw = Gui.getMainWindow()
    toolbar = mw.findChild(QtWidgets.QToolBar, "FreeCADUpdateToolbar")
    if not toolbar:
        toolbar = mw.addToolBar("FreeCAD Update")
        toolbar.setObjectName("FreeCADUpdateToolbar")

    # Supprimer les anciens boutons nommés
    for act in toolbar.actions():
        widget = toolbar.widgetForAction(act)
        if isinstance(widget, QtWidgets.QToolButton) and widget.text() == "Mise à jour FreeCAD":
            toolbar.removeAction(act)

    # Création du bouton
    button = QtWidgets.QToolButton()
    button.setIcon(icon)
    button.setToolTip(tooltip)
    button.setText("Mise à jour FreeCAD")
    button.setAutoRaise(True)
    button.clicked.connect(launch_freecad_downloader)

    # Ajout à la barre d'outils
    action = toolbar.addWidget(button)
    return button

def check_for_updates():
    version_type = get_freecad_version_type()
    tooltip = "Impossible de déterminer la version."
    icon = ICON_ERROR
    local, remote = None, None

    if "Weekly" in version_type:
        local = get_local_build_number()
        remote = get_remote_build_number()
        if local and remote:
            if remote > local:
                tooltip = f"✅ Mise à jour weekly disponible : {remote} > {local}"
                icon = ICON_UPDATE_AVAILABLE
            else:
                tooltip = f"FreeCAD weekly à jour : {local}"
                icon = ICON_UP_TO_DATE
        else:
            tooltip = "❌ Erreur lors de la récupération de la version weekly."
            icon = ICON_ERROR

    elif "Stable" in version_type:
        local = ".".join(App.Version()[0:3])
        remote = get_remote_stable_version()
        if remote:
            if remote > local:
                tooltip = f"✅ Mise à jour stable disponible : {remote} > {local}"
                icon = ICON_UPDATE_AVAILABLE
            else:
                tooltip = f"FreeCAD stable à jour : {local}"
                icon = ICON_UP_TO_DATE
        else:
            tooltip = "❌ Erreur lors de la récupération de la version stable."
            icon = ICON_ERROR

    else:
        tooltip = f"Type de version non pris en charge : {version_type}"
        icon = ICON_UNKNOWN

    # Ajout du bouton
    my_update_button = add_button(icon, tooltip)

    # Affichage tooltip si mise à jour dispo
    if remote and local and remote > local:
        show_update_tooltip(my_update_button, tooltip)


# === FENÊTRE PRINCIPALE ===

class FreeCADDownloader(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("FreeCAD update checker " + CHECKUPDATEVERSION)
        self.setFixedSize(600, 600)
        self.setWindowFlags(QtCore.Qt.Window | QtCore.Qt.WindowStaysOnTopHint)
        self.setPalette(QtWidgets.QApplication.palette())

        self.results = []
        self.old_pos = None

        self.setup_ui()
        self.load_data()

    def setup_ui(self):
        layout = QtWidgets.QVBoxLayout(self)

        self.liste_files = QtWidgets.QTableWidget(0, 2)
        self.liste_files.setHorizontalHeaderLabels(["Nom du fichier", "Action"])
        self.liste_files.verticalHeader().setVisible(False)
        self.liste_files.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.liste_files.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.liste_files.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.liste_files.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.liste_files.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)

        layout.addWidget(self.liste_files)

        self.status_label = QtWidgets.QLabel("Chargement...")
        self.status_label.setAlignment(QtCore.Qt.AlignCenter)
        self.status_label.setMargin(10)
        layout.addWidget(self.status_label)

        button_layout = QtWidgets.QHBoxLayout()
        update_btn = QtWidgets.QPushButton("Actualiser")
        update_btn.clicked.connect(self.force_update)
        close_btn = QtWidgets.QPushButton("Fermer")
        close_btn.clicked.connect(self.close)

        button_layout.addWidget(update_btn)
        button_layout.addWidget(close_btn)
        layout.addLayout(button_layout)

    def load_data(self):
        last_check, cached_results = read_cache()
        now = datetime.now()

        if not last_check or now - last_check > CHECK_INTERVAL:
            self.results = self.fetch_all_files()
            write_cache(now, self.results)
            self.status_label.setText("Vérification des mises à jour effectuée.")
        else:
            self.results = cached_results
            minutes = int((now - last_check).total_seconds() // 60)
            self.status_label.setText(f"Dernière vérification il y a {minutes} minutes.")

        self.update_ui(self.results)

    def force_update(self):
        self.results = self.fetch_all_files()
        write_cache(datetime.now(), self.results)
        self.status_label.setText("Liste actualisée.")
        self.update_ui(self.results)

    def fetch_all_files(self):
        results = []
        def fetch(url, section):
            results.append((section, ""))
            try:
                r = requests.get(url, timeout=10)
                r.raise_for_status()
                for asset in r.json().get("assets", []):
                    name = asset.get("name", "")
                    durl = asset.get("browser_download_url", "")
                    if name.lower().endswith((".appimage", ".7z", ".dmg")):
                        results.append((name, durl))
            except Exception as e:
                App.Console.PrintError(f"❌ Erreur récupération {section} : {e}\\n")

        fetch(URL_STABLE, "Canal Stable :")
        fetch(URL_WEEKLY, "Canal Développement :")
        return results

    def update_ui(self, results):
        self.liste_files.setRowCount(0)

        for name, url in results:
            row = self.liste_files.rowCount()
            self.liste_files.insertRow(row)

            item_name = QtWidgets.QTableWidgetItem(name)
            item_name.setFlags(QtCore.Qt.ItemIsEnabled)

            if not url:
                font = item_name.font()
                font.setBold(True)
                item_name.setFont(font)
                item_name.setBackground(QtGui.QColor("#777777"))
                self.liste_files.setSpan(row, 0, 1, 2)
                self.liste_files.setItem(row, 0, item_name)
            else:
                btn = QtWidgets.QPushButton("Download")
                btn.clicked.connect(partial(webbrowser.open, url))
                self.liste_files.setItem(row, 0, item_name)
                self.liste_files.setCellWidget(row, 1, btn)

    def mousePressEvent(self, event):
        self.old_pos = event.globalPos()

    def mouseMoveEvent(self, event):
        if self.old_pos:
            delta = event.globalPos() - self.old_pos
            self.move(self.pos() + delta)
            self.old_pos = event.globalPos()

# === LANCEMENT ===

def launch_freecad_downloader():
    global freecad_downloader_window

    if freecad_downloader_window is None or not freecad_downloader_window.isVisible():
        freecad_downloader_window = FreeCADDownloader()
        freecad_downloader_window.setWindowFlags(QtCore.Qt.Window)
        freecad_downloader_window.setWindowIcon(QtGui.QIcon(":/icons/freecad"))
        freecad_downloader_window.setAttribute(QtCore.Qt.WA_DeleteOnClose, True)
        freecad_downloader_window.destroyed.connect(lambda: clear_reference())
        freecad_downloader_window.show()
    else:
        freecad_downloader_window.raise_()
        freecad_downloader_window.activateWindow()

def clear_reference():
    global freecad_downloader_window
    freecad_downloader_window = None

def run():
    if App.GuiUp:
        check_for_updates()
    else:
        print("Cette macro nécessite l'interface graphique.")

freecad_downloader_window = None
'''

# Écriture des fichiers
(init_path := mod_path / "InitGui.py").write_text(init_gui_content, encoding='utf-8')
(checkupdate_path := mod_path / "CheckUpdate.py").write_text(check_update_content, encoding='utf-8')

# Confirmation dans la console
App.Console.PrintMessage(f"[CheckUpdate Macro] Fichiers créés :\\n- {init_path}\\n- {checkupdate_path}\\n")

msg = QMessageBox()
msg.setIcon(QMessageBox.Information)
msg.setText(translate("RestartFreeCADWindow",
            "FreeCAD Update Checker successfully installed."))
msg.setInformativeText(translate(
    "RestartFreeCADWindow", "Please restart FreeCAD for changes to take effect. \nRestart FreeCAD ?"))
msg.setWindowTitle(
    translate("RestartFreeCADWindow", "Restart Required"))
msg.setStandardButtons(
    QMessageBox.Yes | QMessageBox.No)

nowButton = msg.button(QMessageBox.Yes)
nowButton.setText(
    translate("RestartFreeCADWindow", "Now"))
laterButton = msg.button(QMessageBox.No)
laterButton.setText(
    translate("RestartFreeCADWindow", "Later"))
response = msg.exec()

if response == QMessageBox.Yes:
    """Shuts down and restarts FreeCAD"""
    args = QtWidgets.QApplication.arguments()[1:]
    if Gui.getMainWindow().close():
        QtCore.QProcess.startDetached(
            QtWidgets.QApplication.applicationFilePath(), args
        )
