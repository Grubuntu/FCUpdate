# FreeCAD Update Checker
#
# Copyright (C) 2025 Grubuntu
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA

# Attribution:
# http://forum.freecadweb.org/
# http://www.freecadweb.org/wiki/index.php?title=Code_snippets
#

# === Contenu du fichier InitGui.py ===
init_gui_content = '''\
from PySide import QtGui
import FreeCAD as App

# auto start code at FreeCAD launch
def runStartupMacros(name):
    if name != "NoneWorkbench":
        Gui.getMainWindow().workbenchActivated.disconnect(runStartupMacros)
        import CheckUpdate
        CheckUpdate.run()

import __main__
__main__.runStartupMacros = runStartupMacros

Gui.getMainWindow().workbenchActivated.connect(runStartupMacros)
'''

# === Contenu du fichier CheckUpdate.py ===
check_update_content = '''\
CHECKUPDATEVERSION = "1.0"

import os
import re
import sys
import json
import time
import webbrowser
import requests
from datetime import datetime, timedelta
from pathlib import Path
from PySide import QtGui, QtCore, QtWidgets
import FreeCAD as App
import FreeCADGui as Gui
from functools import partial
from PySide.QtCore import QTimer, QPoint
from PySide.QtWidgets import QToolTip
translate = App.Qt.translate

# Add translations path
Gui.addLanguagePath(os.path.join(os.path.dirname(__file__), ""))
Gui.updateLocale()

# === CONFIGURATION ===

URL_STABLE = "https://api.github.com/repos/FreeCAD/FreeCAD-Bundle/releases/latest"
URL_WEEKLY = "https://api.github.com/repos/FreeCAD/FreeCAD-Bundle/releases/tags/weekly-builds"

MINIMUM_CHECK_INTERVAL = timedelta(hours=1)

def get_freecad_config_dir():
    if sys.platform == "win32":
        return os.path.join(os.getenv("APPDATA"), "FreeCAD")
    elif sys.platform == "darwin":
        return os.path.join(os.path.expanduser("~"), "Library", "Preferences", "FreeCAD")
    else:
        return os.path.join(os.path.expanduser("~"), ".config", "FreeCAD")

CONFIG_DIR = get_freecad_config_dir()
CONFIG_FILE = os.path.join(CONFIG_DIR, "FCUpdate.cfg")
os.makedirs(CONFIG_DIR, exist_ok=True)

ICON_UP_TO_DATE = QtGui.QApplication.style().standardIcon(QtGui.QStyle.SP_DialogApplyButton)
ICON_UPDATE_AVAILABLE = QtGui.QApplication.style().standardIcon(QtGui.QStyle.SP_BrowserReload)
ICON_ERROR = QtGui.QApplication.style().standardIcon(QtGui.QStyle.SP_MessageBoxWarning)
ICON_UNKNOWN = QtGui.QApplication.style().standardIcon(QtGui.QStyle.SP_TitleBarContextHelpButton)

update_available = False
my_update_button = None

# === FONCTIONS VERSIONS ===

# get type of version : Stable or Dev(Weekly)
def get_freecad_version_type():
    version_info = App.Version()

    if len(version_info) < 6:
        return "FreeCAD (Unknown version)"

    major, minor, patch = version_info[0:3]
    build_info = version_info[3]
    repo_url = version_info[4]
    git_branch = version_info[6] if len(version_info) > 6 else ""
    git_tag = version_info[7] if len(version_info) > 7 else ""

    version_text = str(App.Version())

    # Détection Stable
    if "detached at" in git_branch:
        if major == "1" and minor == "0":
            return "FreeCAD 1.0.x Stable"
        return "FreeCAD Stable Release"

    # Détection Weekly
    if "main" in repo_url.lower():
        return "FreeCAD Weekly Build"

    return (translate("MainWindow", "FreeCAD customised or unknown version"))

# get version of running FreeCAD
def get_local_build_number():
    build_str = App.Version()[3]
    match = re.search(r'(\d+)', build_str)
    return int(match.group(1)) if match else None

# get last weekly version online
def get_remote_build_number():
    try:
        with requests.get(URL_WEEKLY, timeout=10) as r:
            r.raise_for_status()
            html = r.text
            match = re.search(r"FreeCAD_weekly-builds-(\d+)-", html)
            return int(match.group(1)) if match else None
    except Exception as e:
        App.Console.PrintError(translate("MainWindow", "Error retrieving weekly online version:{}\\n").format(e))
        return None

# get last stable version online
def get_remote_stable_version():
    try:
        r = requests.get(URL_STABLE, timeout=10)
        r.raise_for_status()
        data = r.json()
        tag = data.get("tag_name", "")
        match = re.match(r"v?(\d+\.\d+\.\d+)", tag)
        return match.group(1) if match else None
    except Exception as e:
        App.Console.PrintError(translate("MainWindow", "Error retrieving stable online version:{}\\n").format(e))
        return None

# === CACHE TEMPOREL ===

# read data in cache to limit API access 
def read_cache():
    if not os.path.exists(CONFIG_FILE):
        return None, []
    try:
        with open(CONFIG_FILE, "r") as f:
            data = json.load(f)
            last_check = datetime.fromisoformat(data.get("last_check", ""))
            results = data.get("results_cache", [])
            return last_check, results
    except Exception:
        return None, []

# save data in cache
def write_cache(last_check, results_cache):
    with open(CONFIG_FILE, "w") as f:
        json.dump({
            "last_check": last_check.isoformat() if last_check else "",
            "results_cache": results_cache
        }, f, indent=4)

# === BOUTON / INTERFACE ===

# pop a tooltip in FreeCAD when there is an update available
def show_update_tooltip(widget, message, delay_ms=15000):
    """Affiche un tooltip centré sur le widget donné après un délai."""
    if not widget:
        print("Error : widget is None")
        return

    def show():
        pos = widget.mapToGlobal(widget.rect().center())
        QToolTip.showText(pos, message, widget)

    QTimer.singleShot(delay_ms, show)

# add the toolbar and the button action of Update Checker in FreeCAD
def add_button(icon, tooltip):
    """Ajoute un QToolButton dans la barre d'outils (et le retourne pour interaction)."""
    mw = Gui.getMainWindow()
    toolbar = mw.findChild(QtWidgets.QToolBar, "FreeCADUpdateToolbar")
    if not toolbar:
        toolbar = mw.addToolBar("FreeCAD Update")
        toolbar.setObjectName("FreeCADUpdateToolbar")

    # Supprimer les anciens boutons nommés
    for act in toolbar.actions():
        widget = toolbar.widgetForAction(act)
        if isinstance(widget, QtWidgets.QToolButton) and widget.text() == "FreeCAD Update":
            toolbar.removeAction(act)

    # Création du bouton
    button = QtWidgets.QToolButton()
    button.setIcon(icon)
    button.setToolTip(tooltip)
    button.setText("Mise à jour FreeCAD")
    button.setAutoRaise(True)
    button.clicked.connect(launch_freecad_downloader)

    # Ajout à la barre d'outils
    action = toolbar.addWidget(button)
    return button

# check the updates available online
def check_for_updates():
    version_type = get_freecad_version_type()
    tooltip = translate("Tooltip", "Unable to determine the version.")
    icon = ICON_ERROR
    local, remote = None, None

    if "Weekly" in version_type:
        local = get_local_build_number()
        remote = get_remote_build_number()
        if local and remote:
            if remote > local:
                tooltip = translate("MainWindow", "✅ Weekly update available : {} > {}").format(remote, local)
                icon = ICON_UPDATE_AVAILABLE
            else:
                tooltip = f"FreeCAD weekly à jour : {local}"
                icon = ICON_UP_TO_DATE
        else:
            tooltip = translate("MainWindow", "❌ Error recovering weekly version.")
            icon = ICON_ERROR

    elif "Stable" in version_type:
        local = ".".join(App.Version()[0:3])
        remote = get_remote_stable_version()
        if remote:
            if remote > local:
                tooltip = translate("Tooltip", "✅ Stable update available : {} > {}").format(remote, local)
                icon = ICON_UPDATE_AVAILABLE
            else:
                tooltip = translate("Tooltip", "FreeCAD is up to date : {}").format(local)
                icon = ICON_UP_TO_DATE
        else:
            tooltip = translate("Tooltip", "❌ Error recovering the stable version.")
            icon = ICON_ERROR

    else:
        tooltip = translate("Tooltip", "Version type not supported : {}").format(version_type)
        icon = ICON_UNKNOWN

    # Ajout du bouton
    global my_update_button
    if not my_update_button:
        my_update_button = add_button(icon, tooltip)

    # Affichage tooltip si mise à jour dispo
    if remote and local and remote > local:
        global update_available
        update_available = True
        show_update_tooltip(my_update_button, tooltip)
    else:
        update_available = False
    return update_available

# === FENÊTRE PRINCIPALE ===

# main class for FreeCAD Update Checker
class FreeCADUpdateChecker(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("FreeCAD update checker " + CHECKUPDATEVERSION)
        self.setFixedSize(600, 600)
        self.setWindowFlags(QtCore.Qt.Window | QtCore.Qt.WindowStaysOnTopHint)
        self.setPalette(QtWidgets.QApplication.palette())

        self.results = []

        self.setup_ui()
        self.load_data()

    def setup_ui(self):
        layout = QtWidgets.QVBoxLayout(self)

        self.liste_files = QtWidgets.QTableWidget(0, 2)
        self.liste_files.setHorizontalHeaderLabels([translate("Table","File name"), translate("Table", "Action")])
        self.liste_files.verticalHeader().setVisible(False)
        self.liste_files.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.liste_files.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.liste_files.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.liste_files.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.liste_files.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)

        layout.addWidget(self.liste_files)

        self.status_label = QtWidgets.QLabel(translate("Status", "Loading..."))
        self.status_label.setAlignment(QtCore.Qt.AlignCenter)
        self.status_label.setMargin(10)
        layout.addWidget(self.status_label)

        button_layout = QtWidgets.QHBoxLayout()
        update_btn = QtWidgets.QPushButton(translate("MainWindow", "Reload"))
        update_btn.clicked.connect(self.force_update)
        close_btn = QtWidgets.QPushButton(translate("MainWindow", "Close"))
        close_btn.clicked.connect(self.close)

        button_layout.addWidget(update_btn)
        button_layout.addWidget(close_btn)
        layout.addLayout(button_layout)

    def load_data(self):
        last_check, cached_results = read_cache()
        now = datetime.now()
        global update_available
        if not last_check or now - last_check > MINIMUM_CHECK_INTERVAL:
            self.results = self.fetch_all_files()
            write_cache(now, self.results)
            self.status_label.setText(translate("Status", "Updates checked."))
            if update_available :
                self.status_label.setText(translate("Status", "Updates checked. An update is available !"))
        else:
            self.results = cached_results
            minutes = int((now - last_check).total_seconds() // 60)
            self.status_label.setText(translate("Status", "Last check {} minutes ago.").format(minutes))
            if update_available :
                self.status_label.setText(translate("Status", "Last check {} minutes ago. An update is available !").format(minutes))

        self.update_ui(self.results)

    def force_update(self):
        global update_available
        self.results = self.fetch_all_files()
        check_for_updates()
        write_cache(datetime.now(), self.results)
        self.status_label.setText(translate("Status", "Updates checked no update available."))
        if update_available :
            self.status_label.setText(translate("Status", "Updates checked. An update is available !"))
        self.update_ui(self.results)

    # construct list of files available
    def fetch_all_files(self):
        results = []
        def fetch(url, section):
            results.append((section, ""))
            try:
                r = requests.get(url, timeout=10)
                r.raise_for_status()
                for asset in r.json().get("assets", []):
                    name = asset.get("name", "")
                    durl = asset.get("browser_download_url", "")
                    if name.lower().endswith((".appimage", ".7z", ".dmg")):
                        results.append((name, durl))
            except Exception as e:
                App.Console.PrintError(translate("Console", "❌ Error retrieving {} : {}\\n").format(section, e))

        fetch(URL_STABLE, translate("Table", "Canal Stable :"))
        fetch(URL_WEEKLY, translate("Table", "Canal Development :"))
        return results

    # update list of files in tablewidget
    def update_ui(self, results):
        self.liste_files.setRowCount(0)

        for name, url in results:
            row = self.liste_files.rowCount()
            self.liste_files.insertRow(row)

            item_name = QtWidgets.QTableWidgetItem(name)
            item_name.setFlags(QtCore.Qt.ItemIsEnabled)

            if not url:
                font = item_name.font()
                font.setBold(True)
                item_name.setFont(font)
                item_name.setBackground(QtGui.QColor("#777777"))
                self.liste_files.setSpan(row, 0, 1, 2)
                self.liste_files.setItem(row, 0, item_name)
            else:
                btn = QtWidgets.QPushButton(translate("Table", "Download"))
                btn.clicked.connect(partial(webbrowser.open, url))
                self.liste_files.setItem(row, 0, item_name)
                self.liste_files.setCellWidget(row, 1, btn)

# === LANCEMENT ===

def launch_freecad_downloader():
    global freecad_downloader_window

    if freecad_downloader_window is None or not freecad_downloader_window.isVisible():
        freecad_downloader_window = FreeCADUpdateChecker()
        freecad_downloader_window.setWindowFlags(QtCore.Qt.Window)
        freecad_downloader_window.setWindowIcon(QtGui.QIcon(":/icons/freecad"))
        freecad_downloader_window.setAttribute(QtCore.Qt.WA_DeleteOnClose, True)
        freecad_downloader_window.destroyed.connect(lambda: clear_reference())
        freecad_downloader_window.show()
    else:
        freecad_downloader_window.raise_()
        freecad_downloader_window.activateWindow()

def clear_reference():
    global freecad_downloader_window
    freecad_downloader_window = None

def run():
    if App.GuiUp:
        check_for_updates()
    else:
        print(translate("Console", "This macro requires FreeCAD graphique interface."))

freecad_downloader_window = None

'''

import os
import platform
from pathlib import Path
from PySide import QtCore, QtGui, QtWidgets
from PySide.QtWidgets import QMessageBox

translate = App.Qt.translate

# Path to user directory depending OS
def get_freecad_user_mod_path():
    system = platform.system()
    if system == "Windows":
        base_path = Path(os.getenv('APPDATA')) / "FreeCAD"
    elif system == "Darwin":  # macOS
        base_path = Path.home() / "Library" / "Preferences" / "FreeCAD"
    else:  # Linux and others
        base_path = Path.home() / ".FreeCAD"
    return base_path / "Mod" / "CheckUpdate"

# box to ask the user for authorisation to install
def show_installation_dialog():
    msg_box = QMessageBox()
    msg_box.setIcon(QMessageBox.Information)
    msg_box.setWindowTitle(
    translate("Installation Window", "FreeCAD Update Checker installation"))
    msg_box.setText(translate("Installation Window", "This macro will create a folder in your user space to install the files needed to check for FreeCAD updates. If FreeCAD Update Checker is already installed, the files will be overwritten."))
    msg_box.setInformativeText(translate("Installation Window", "Do you want to continue ?"))
    msg_box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
    msg_box.setDefaultButton(QMessageBox.Yes)

    response = msg_box.exec()
    return response == QMessageBox.Yes

# run dialog and create directory and files needed
if show_installation_dialog():
    mod_path = get_freecad_user_mod_path()
    mod_path.mkdir(parents=True, exist_ok=True)


    # Écriture des fichiers
    (init_path := mod_path / "InitGui.py").write_text(init_gui_content, encoding='utf-8')
    (checkupdate_path := mod_path / "CheckUpdate.py").write_text(check_update_content, encoding='utf-8')

    # ask to restart FreeCAD
    msg = QMessageBox()
    msg.setIcon(QMessageBox.Information)
    msg.setText(translate("RestartFreeCADWindow",
                "FreeCAD Update Checker successfully installed."))
    msg.setInformativeText(translate(
        "RestartFreeCADWindow", "Please restart FreeCAD for changes to take effect. \nRestart FreeCAD ?"))
    msg.setWindowTitle(
        translate("RestartFreeCADWindow", "Restart Required"))
    msg.setStandardButtons(
        QMessageBox.Yes | QMessageBox.No)

    nowButton = msg.button(QMessageBox.Yes)
    nowButton.setText(
        translate("RestartFreeCADWindow", "Now"))
    laterButton = msg.button(QMessageBox.No)
    laterButton.setText(
        translate("RestartFreeCADWindow", "Later"))
    response = msg.exec()

    if response == QMessageBox.Yes:
        """Shuts down and restarts FreeCAD"""
        args = QtWidgets.QApplication.arguments()[1:]
        if Gui.getMainWindow().close():
            QtCore.QProcess.startDetached(
                QtWidgets.QApplication.applicationFilePath(), args
            )
else:
    QtWidgets.QMessageBox.information(None, translate("Installation Window", "Installation cancelled"), translate("Installation Window", "No files have been installed."))
