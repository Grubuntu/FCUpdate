# FCUpdate
#
# Copyright (C) 2025 Grubuntu
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA

# Attribution:
# http://forum.freecadweb.org/
# http://www.freecadweb.org/wiki/index.php?title=Code_snippets
#

# voir pour afficher la version actuelle et mettre en valeur la mise √† jour dispo

# === Contenu du fichier InitGui.py ===
init_gui_content = '''\
from PySide import QtGui
import FreeCAD as App

# auto start code at FreeCAD launch
def runStartupMacros(name):

    if name != "NoneWorkbench":
        Gui.getMainWindow().workbenchActivated.disconnect(runStartupMacros)
        import FCUpdate
        FCUpdate.run()

import __main__
__main__.runStartupMacros = runStartupMacros

Gui.getMainWindow().workbenchActivated.connect(runStartupMacros)
'''

# === Contenu du fichier FCUpdate.py ===
check_update_content = '''\
FCUPDATEVERSION = "1.0"

import os
import re
import sys
import json
import time
import webbrowser
import requests
from datetime import datetime, timedelta
from pathlib import Path
from PySide import QtGui, QtCore, QtWidgets
import FreeCAD as App
import FreeCADGui as Gui
from functools import partial
from PySide.QtCore import QTimer, QPoint
from PySide.QtWidgets import QToolTip, QToolBar
translate = App.Qt.translate

# Add translations path
Gui.addLanguagePath(os.path.join(os.path.dirname(__file__), "translations"))
Gui.updateLocale()

# === CONFIGURATION ===
URL_STABLE = "https://api.github.com/repos/FreeCAD/FreeCAD-Bundle/releases/latest"
URL_WEEKLY = "https://api.github.com/repos/FreeCAD/FreeCAD-Bundle/releases/tags/weekly-builds"

MINIMUM_CHECK_INTERVAL = timedelta(hours=1)

def get_freecad_config_dir():
    if sys.platform == "win32":
        return os.path.join(os.getenv("APPDATA"), "FreeCAD")
    elif sys.platform == "darwin":
        return os.path.join(os.path.expanduser("~"), "Library", "Preferences", "FreeCAD")
    else:
        return os.path.join(os.path.expanduser("~"), ".config", "FreeCAD")

CONFIG_DIR = get_freecad_config_dir()
CONFIG_FILE = os.path.join(CONFIG_DIR, "FCUpdate.cfg")
os.makedirs(CONFIG_DIR, exist_ok=True)

ICON_UPDATE = QtGui.QApplication.style().standardIcon(QtGui.QStyle.SP_BrowserReload)

update_available = False

# === FONCTIONS VERSIONS ===
# get type of version : Stable or Dev(Weekly)
def get_freecad_version_type():
    version_info = App.Version()

    if len(version_info) < 6:
        return "FreeCAD (Unknown version)"

    major, minor, patch = version_info[0:3]
    build_info = version_info[3]
    repo_url = version_info[4]
    git_branch = version_info[6] if len(version_info) > 6 else ""
    git_tag = version_info[7] if len(version_info) > 7 else ""

    version_text = str(App.Version())

    # D√©tection Stable
    if "detached at" in git_branch:
        if major == "1" and minor == "0":
            return "FreeCAD 1.0.x Stable"
        return "FreeCAD Stable Release"

    # D√©tection Weekly
    if "main" in repo_url.lower():
        return "FreeCAD Weekly Build"

    return (translate("MainWindow", "FreeCAD customised or unknown version"))

# get curent version of FreeCAD
def get_local_build_number():
    build_str = App.Version()[3]
    match = re.search(r'(\d+)', build_str)
    return int(match.group(1)) if match else None

# get last weekly version online
def get_remote_build_number():
    try:
        with requests.get(URL_WEEKLY, timeout=10) as r:
            r.raise_for_status()
            html = r.text
            match = re.search(r"FreeCAD_weekly-builds-(\d+)-", html)
            return int(match.group(1)) if match else None
    except Exception as e:
        App.Console.PrintError(translate("MainWindow", "Error retrieving online version:{}").format(e))
        return None

# get last stable version online
def get_remote_stable_version():
    try:
        r = requests.get(URL_STABLE, timeout=10)
        r.raise_for_status()
        data = r.json()
        tag = data.get("tag_name", "")
        match = re.match(r"v?(\d+\.\d+\.\d+)", tag)
        return match.group(1) if match else None
    except Exception as e:
        App.Console.PrintError(translate("MainWindow", "Error retrieving online version:{}").format(e))
        return None

# === CACHE ===
# read data in cache to limit API access 
def read_cache():
    if not os.path.exists(CONFIG_FILE):
        return None, []
    try:
        with open(CONFIG_FILE, "r") as f:
            data = json.load(f)
            last_check = datetime.fromisoformat(data.get("last_check", ""))
            results = data.get("results_cache", [])
            return last_check, results
    except Exception:
        return None, []

# save data in cache
def write_cache(last_check, results_cache):
    with open(CONFIG_FILE, "w") as f:
        json.dump({
            "last_check": last_check.isoformat() if last_check else "",
            "results_cache": results_cache
        }, f, indent=4)

# === BOUTON / INTERFACE ===
# add menu FCUpdate in FreeCAD
def waitFreeCADReady():
    mw = Gui.getMainWindow()
    startAM = False
    try:
        mw.mainWindowClosed
        mw.workbenchActivated
        startAM = True
    except AttributeError:
        pass
    if startAM:
        t.stop()
        t.deleteLater()
        addMenu()
        mw = Gui.getMainWindow()
        mw.workbenchActivated.connect(addMenu)

def addMenu():
    mw = Gui.getMainWindow()
    action = mw.findChild(QtGui.QAction, "FCUpdateMenu")
    if not action:
        actionFCUpdate.setObjectName("FCUpdateMenu")
        actionFCUpdate.triggered.connect(display_freecad_update)
        iconeFCUpdate.setObjectName("FCUpdateMenu")
        iconeFCUpdate.triggered.connect(display_freecad_update)
        iconeFCUpdate.setIcon(ICON_UPDATE)
        
        mw.menuBar().addAction(actionFCUpdate)
        menu = QtGui.QMenu()

        #### code pour ajouter un sous menu plus tard...
        ## cr√©ation d'un sous-menu 
        # sousMenu = QtGui.QAction(mw)
        # sousMenu.setText(translate("Menu", "Texte Sous Menu 1"))
        # sousMenu.setObjectName("Sous Menu 1")
        # sousMenu.triggered.connect(UneAction)
        ## definir le bouton actionFCUpdate comme Menu
        # actionFCUpdate.setMenu(menu)
        ## ajouter le sous menu
        # menu.addAction(sousMenu)

    # Mise √† jour du texte selon l'√©tat
    if update_available:
        mw.menuBar().addAction(iconeFCUpdate)

    else:
        mw.menuBar().removeAction(iconeFCUpdate)
    return actionFCUpdate


# check the updates available online
def check_for_updates():
    version_type = get_freecad_version_type()
    tooltip = translate("Tooltip", "‚ÅâÔ∏è Unable to determine the version.")
    local, remote = None, None

    if "Weekly" in version_type:
        local = get_local_build_number()
        remote = get_remote_build_number()
    elif "Stable" in version_type:
        local = ".".join(App.Version()[0:3])
        remote = get_remote_stable_version()

    # Affichage mise √† jour dispo
    if remote and local and remote > local:
        global update_available
        update_available = True
        # actionFCUpdate.setText("üöÄ FCUpdate")
        mw.menuBar().addAction(iconeFCUpdate)
    else:
        update_available = False
        # actionFCUpdate.setText("FCUpdate")
        mw.menuBar().removeAction(iconeFCUpdate)
    return update_available

def load_config():
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "r") as f:
            return json.load(f)
    return {}

def save_config(config):
    with open(CONFIG_FILE, "w") as f:
        json.dump(config, f, indent=4)

def get_file_type(file_name):
    if file_name.endswith("SHA256.txt") or "SHA256" in file_name:
        return "SHA256"
    elif file_name.endswith(".exe") or "Windows" in file_name:
        return "Windows"
    elif file_name.endswith(".AppImage") or "Linux" in file_name:
        return "Linux"
    elif file_name.endswith(".dmg") or "Mac" in file_name:
        return "MacOS"
    elif file_name.endswith(".tar.gz") or file_name.endswith(".zip"):
        return "Source"
    return "Other"

# === FEN√äTRE PRINCIPALE ===
# main class for FCUpdate
class FreeCADUpdateChecker(QtWidgets.QDialog):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("FCUpdate " + FCUPDATEVERSION)
        self.setFixedSize(600, 600)
        self.setWindowFlags(QtCore.Qt.Window | QtCore.Qt.WindowStaysOnTopHint)
        self.setPalette(QtWidgets.QApplication.palette())
        self.setModal(True)
        self.results = []
        self.setup_ui()
        self.load_data()

    def setup_ui(self):
        layout = QtWidgets.QVBoxLayout(self)

        self.liste_files = QtWidgets.QTableWidget(0, 2)
        self.liste_files.horizontalHeader().setVisible(False)
        self.liste_files.verticalHeader().setVisible(False)
        self.liste_files.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.liste_files.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.liste_files.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.liste_files.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.liste_files.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)

        # Zone des checkboxes de filtrage
        self.filter_checkboxes = {}
        filter_layout = QtWidgets.QHBoxLayout()

        # Valeurs des types √† filtrer
        filter_types = ["Windows", "Linux", "MacOS", "Source", "SHA256"]
        self.config = load_config()

        for name in filter_types:
            cb = QtWidgets.QCheckBox(name)
            cb.setChecked(self.config.get("filter_" + name, True))
            cb.stateChanged.connect(self.apply_filter)
            self.filter_checkboxes[name] = cb
            filter_layout.addWidget(cb)

        self.status_label = QtWidgets.QLabel(translate("Status", "Loading..."))
        self.status_label.setAlignment(QtCore.Qt.AlignCenter)
        self.status_label.setMargin(10)

        button_layout = QtWidgets.QHBoxLayout()
        update_btn = QtWidgets.QPushButton(translate("MainWindow", "Reload"))
        update_btn.clicked.connect(self.force_update)
        close_btn = QtWidgets.QPushButton(translate("MainWindow", "Close"))
        close_btn.clicked.connect(self.close)

        button_layout.addWidget(update_btn)
        button_layout.addWidget(close_btn)

        layout.addWidget(self.liste_files)
        layout.addLayout(filter_layout)
        layout.addWidget(self.status_label)
        layout.addLayout(button_layout)

        # Appel initial du filtre si des fichiers sont d√©j√† charg√©s
        self.apply_filter()

    def apply_filter(self):
        for key, cb in self.filter_checkboxes.items():
            self.config["filter_" + key] = cb.isChecked()
        save_config(self.config)

        for row in range(self.liste_files.rowCount()):
            item = self.liste_files.item(row, 0)
            if item is None:
                continue
            data_type = item.data(QtCore.Qt.UserRole)

            if data_type == "section":
                self.liste_files.setRowHidden(row, False)
            else:
                file_name = item.text()
                file_type = get_file_type(file_name)
                visible = self.filter_checkboxes.get(file_type, QtWidgets.QCheckBox()).isChecked()
                self.liste_files.setRowHidden(row, not visible)

    def load_data(self):
        last_check, cached_results = read_cache()
        now = datetime.now()
        global update_available
        if not last_check or now - last_check > MINIMUM_CHECK_INTERVAL:
            self.results = self.fetch_all_files()
            write_cache(now, self.results)
            self.status_label.setText(translate("Status", "Updates checked."))
            if update_available :
                self.status_label.setText(translate("Status", "Updates checked. An update is available !"))
        else:
            self.results = cached_results
            minutes = int((now - last_check).total_seconds() // 60)
            self.status_label.setText(translate("Status", "Last check {} minutes ago.").format(minutes))
            if update_available :
                self.status_label.setText(translate("Status", "Last check {} minutes ago. An update is available !").format(minutes))

        self.update_ui(self.results)

    def force_update(self):
        global update_available
        self.results = self.fetch_all_files()
        check_for_updates()
        write_cache(datetime.now(), self.results)
        self.status_label.setText(translate("Status", "Updates checked no update available."))
        if update_available :
            self.status_label.setText(translate("Status", "Updates checked. An update is available !"))
        self.update_ui(self.results)

    # construct list of files available
    def fetch_all_files(self):
        results = []
        def fetch(url, section):
            results.append((section, ""))
            try:
                r = requests.get(url, timeout=10)
                r.raise_for_status()
                for asset in r.json().get("assets", []):
                    name = asset.get("name", "")
                    durl = asset.get("browser_download_url", "")
                    results.append((name, durl))
            except Exception as e:
                App.Console.PrintError(translate("Console", "‚ùå Error retrieving {} : {}").format(section, e))

        fetch(URL_STABLE, translate("Table", "Canal Stable :"))
        fetch(URL_WEEKLY, translate("Table", "Canal Development :"))
        return results

    # update list of files in tablewidget
    def update_ui(self, results):
        self.liste_files.setRowCount(0)

        for name, url in results:
            row = self.liste_files.rowCount()
            self.liste_files.insertRow(row)

            item_name = QtWidgets.QTableWidgetItem(name)
            item_name.setFlags(QtCore.Qt.ItemIsEnabled)

            if not url:
                font = item_name.font()
                font.setBold(True)
                item_name.setFont(font)
                item_name.setBackground(QtGui.QColor("#777777"))
                item_name.setFlags(QtCore.Qt.ItemIsEnabled)
                item_name.setData(QtCore.Qt.UserRole, "section")  # Marque comme section
                self.liste_files.setSpan(row, 0, 1, 2)
                self.liste_files.setItem(row, 0, item_name)
            else:
                item_name.setData(QtCore.Qt.UserRole, "file")  # Marque comme fichier
                btn = QtWidgets.QPushButton(translate("Table", "Download"))
                btn.clicked.connect(partial(webbrowser.open, url))
                self.liste_files.setItem(row, 0, item_name)
                self.liste_files.setCellWidget(row, 1, btn)
        self.apply_filter()

# === LANCEMENT ===
def display_freecad_update():
    global display_update_window
    display_update_window = FreeCADUpdateChecker()
    display_update_window.setWindowFlags(QtCore.Qt.Window)
    display_update_window.setWindowIcon(QtGui.QIcon(":/icons/freecad"))
    display_update_window.setAttribute(QtCore.Qt.WA_DeleteOnClose, True)
    display_update_window.destroyed.connect(clear_reference)
    display_update_window.show()

def clear_reference():
    global display_update_window
    display_update_window = None

t = QtCore.QTimer()

def run():
    t.timeout.connect(waitFreeCADReady)
    t.start(500)
    if App.GuiUp:
        check_for_updates()
    else:
        print(translate("Console", "This macro requires FreeCAD graphique interface."))

display_update_window = None
mw = Gui.getMainWindow()
actionFCUpdate = QtGui.QAction("FCUpdate", mw)
iconeFCUpdate = QtGui.QAction("", mw)
'''

import os
import socket
import json
import locale
import platform
import urllib.request
from pathlib import Path
from PySide import QtCore, QtGui, QtWidgets
from PySide.QtWidgets import (
    QMessageBox, QCheckBox, QDialog, QVBoxLayout,
    QLabel, QPushButton, QDialogButtonBox, QProgressDialog
)

# --- Internals translations ---
locales_table = {'English': 'en', 'Afrikaans': 'af', 'Arabic': 'ar', 'Basque': 'eu', 'Catalan': 'ca', 'Chinese Simplified': 'zh-CN', 'Chinese Traditional': 'zh-TW', 'Croatian': 'hr', 'Czech': 'cs', 'Dutch': 'nl', 'Filipino': 'fil', 'Finnish': 'fi', 'French': 'fr', 'Galician': 'gl', 'German': 'de', 'Hungarian': 'hu', 'Indonesian': 'id', 'Italian': 'it', 'Japanese': 'ja', 'Kabyle': 'kab', 'Korean': 'ko', 'Lithuanian': 'lt', 'Norwegian': 'no', 'Polish': 'pl', 'Portuguese': 'pt-PT', 'Portuguese, Brazilian': 'pt-BR', 'Romanian': 'ro', 'Russian': 'ru', 'Slovak': 'sk', 'Slovenian': 'sl', 'Spanish': 'es-ES', 'Swedish': 'sv-SE', 'Turkish': 'tr', 'Ukrainian': 'uk', 'Valencian': 'val-ES', 'Vietnamese': 'vi'}

translations = {
    'French': {
        "FCUpdate installation": "Installation de FCUpdate",
        "This macro will create a folder in your user space to install the files needed to check for FreeCAD updates. If FCUpdate is already installed, the files will be overwritten. \n Would you like to continue ?":
            "Cette macro va cr√©er un dossier dans votre espace utilisateur pour installer les fichiers n√©cessaires √† la v√©rification des mises √† jour de FreeCAD. Si FCUpdate est d√©j√† install√©, les fichiers seront √©cras√©s.\nSouhaitez-vous continuer ?",
        "Install language packs": "Installer les packs de langue",
        "Yes": "Oui",
        "No": "Non",
        "Error": "Erreur",
        "No Internet connection": "Pas de connexion Internet",
        "Could not download translations because the computer is offline.": "Impossible de t√©l√©charger les traductions car l'ordinateur est hors ligne.",
        "FCUpdate successfully installed.": "FCUpdate a √©t√© install√© avec succ√®s.",
        "Please restart FreeCAD for changes to take effect.\nRestart FreeCAD?": "Veuillez red√©marrer FreeCAD pour que les modifications prennent effet.\nRed√©marrer FreeCAD ?",
        "Restart Required": "Red√©marrage requis",
        "Now": "Maintenant",
        "Later": "Plus tard",
        "Installation cancelled": "Installation annul√©e",
        "No files have been installed.": "Aucun fichier n‚Äôa √©t√© install√©.",
    },
    'German': {
        "FCUpdate installation": "Installation des FCUpdate",
        "This macro will create a folder in your user space to install the files needed to check for FreeCAD updates. If FCUpdate is already installed, the files will be overwritten. \n Would you like to continue ?":
            "Dieses Makro erstellt einen Ordner in Ihrem Benutzerverzeichnis, um die Dateien zu installieren, die zum √úberpr√ºfen von FreeCAD-Updates erforderlich sind. Wenn FCUpdate bereits installiert ist, werden die Dateien √ºberschrieben.\nM√∂chten Sie fortfahren?",
        "Install language packs": "Sprachpakete installieren",
        "Yes": "Ja",
        "No": "Nein",
        "Error": "Fehler",
        "No Internet connection": "Keine Internetverbindung",
        "Could not download translations because the computer is offline.": "√úbersetzungen konnten nicht heruntergeladen werden, da der Computer offline ist.",
        "FCUpdate successfully installed.": "FCUpdate wurde erfolgreich installiert.",
        "Please restart FreeCAD for changes to take effect.\nRestart FreeCAD?": "Bitte starten Sie FreeCAD neu, damit die √Ñnderungen wirksam werden.\nFreeCAD jetzt neu starten?",
        "Restart Required": "Neustart erforderlich",
        "Now": "Jetzt",
        "Later": "Sp√§ter",
        "Installation cancelled": "Installation abgebrochen",
        "No files have been installed.": "Es wurden keine Dateien installiert.",
    },
    'Spanish': {
        "FCUpdate installation": "Instalaci√≥n de FCUpdate",
        "This macro will create a folder in your user space to install the files needed to check for FreeCAD updates. If FCUpdate is already installed, the files will be overwritten. \n Would you like to continue ?":
            "Esta macro crear√° una carpeta en tu espacio de usuario para instalar los archivos necesarios para comprobar las actualizaciones de FreeCAD. Si FCUpdate ya est√° instalado, los archivos ser√°n sobrescritos.\n¬øDeseas continuar?",
        "Install language packs": "Instalar paquetes de idioma",
        "Yes": "S√≠",
        "No": "No",
        "Error": "Error",
        "No Internet connection": "Sin conexi√≥n a Internet",
        "Could not download translations because the computer is offline.": "No se pudieron descargar las traducciones porque el equipo est√° sin conexi√≥n.",
        "FCUpdate successfully installed.": "FCUpdate se ha instalado correctamente.",
        "Please restart FreeCAD for changes to take effect.\nRestart FreeCAD?": "Por favor, reinicia FreeCAD para que los cambios surtan efecto.\n¬øReiniciar FreeCAD?",
        "Restart Required": "Reinicio requerido",
        "Now": "Ahora",
        "Later": "M√°s tarde",
        "Installation cancelled": "Instalaci√≥n cancelada",
        "No files have been installed.": "No se ha instalado ning√∫n archivo.",
    },
    'Polish': {
        "FCUpdate installation": "Instalacja FCUpdate",
        "This macro will create a folder in your user space to install the files needed to check for FreeCAD updates. If FCUpdate is already installed, the files will be overwritten. \n Would you like to continue ?":
            "Makro utworzy folder w Twojej przestrzeni u≈ºytkownika, aby zainstalowaƒá pliki potrzebne do sprawdzania aktualizacji FreeCAD. Je≈õli FCUpdate jest ju≈º zainstalowany, pliki zostanƒÖ nadpisane.\nCzy chcesz kontynuowaƒá?",
        "Install language packs": "Zainstaluj pakiety jƒôzykowe",
        "Yes": "Tak",
        "No": "Nie",
        "Error": "B≈ÇƒÖd",
        "No Internet connection": "Brak po≈ÇƒÖczenia z Internetem",
        "Could not download translations because the computer is offline.": "Nie mo≈ºna pobraƒá t≈Çumacze≈Ñ, poniewa≈º komputer jest offline.",
        "FCUpdate successfully installed.": "FCUpdate zosta≈Ç pomy≈õlnie zainstalowany.",
        "Please restart FreeCAD for changes to take effect.\nRestart FreeCAD?": "Uruchom ponownie FreeCAD, aby zmiany zaczƒô≈Çy obowiƒÖzywaƒá.\nUruchomiƒá ponownie FreeCAD?",
        "Restart Required": "Wymagane ponowne uruchomienie",
        "Now": "Teraz",
        "Later": "P√≥≈∫niej",
        "Installation cancelled": "Instalacja anulowana",
        "No files have been installed.": "Nie zainstalowano ≈ºadnych plik√≥w.",
    },
    'English': {}  # Default value
}

def get_user_language():
    lang = App.ParamGet("User parameter:BaseApp/Preferences/General").GetString("Language", "")
    if lang and lang != "Default":
        return lang
    else:
        'English'

lang = get_user_language()

def tr(text):
    return translations.get(lang, {}).get(text, text)

# --- Class dialog ---
class InstallationDialog(QDialog):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(tr("FCUpdate installation"))
        self.setModal(True)
        self.resize(400, 200)

        layout = QVBoxLayout(self)

        label = QLabel(tr("This macro will create a folder in your user space to install the files needed to check for FreeCAD updates. If FCUpdate is already installed, the files will be overwritten. \n Would you like to continue ?"))
        label.setWordWrap(True)
        layout.addWidget(label)

        self.checkbox = QCheckBox(tr("Install language packs"))
        layout.addWidget(self.checkbox)

        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Yes | QtWidgets.QDialogButtonBox.No)
        buttons.button(QtWidgets.QDialogButtonBox.Yes).setText(tr("Yes"))
        buttons.button(QtWidgets.QDialogButtonBox.No).setText(tr("No"))
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    def is_checked(self):
        return self.checkbox.isChecked()

def has_internet_connection(host="8.8.8.8", port=53, timeout=3):
    try:
        socket.setdefaulttimeout(timeout)
        socket.socket(socket.AF_INET, socket.SOCK_STREAM).connect((host, port))
        return True
    except Exception:
        return False

def download_translations(destination_folder):
    api_url = "https://api.github.com/repos/Grubuntu/FCUpdate/contents/translations"
    headers = {'Accept': 'application/vnd.github.v3+json'}

    progress_dialog = QtWidgets.QProgressDialog(
        tr("Downloading translation files..."), tr("Cancel"), 0, 0)
    progress_dialog.setWindowModality(QtCore.Qt.ApplicationModal)
    progress_dialog.setMinimumDuration(0)
    progress_dialog.setValue(0)
    progress_dialog.show()
    QtWidgets.QApplication.processEvents()

    try:
        request = urllib.request.Request(api_url, headers=headers)
        with urllib.request.urlopen(request) as response:
            data = json.loads(response.read().decode())

        total_files = len([f for f in data if f['name'].endswith('.qm') or f['name'].endswith('.ts')])
        progress_dialog.setMaximum(total_files)

        downloaded = 0
        for file_info in data:
            if file_info['name'].endswith('.qm') or file_info['name'].endswith('.ts'):
                if progress_dialog.wasCanceled():
                    break
                download_url = file_info['download_url']
                file_path = destination_folder / file_info['name']
                urllib.request.urlretrieve(download_url, file_path)
                downloaded += 1
                progress_dialog.setValue(downloaded)
                QtWidgets.QApplication.processEvents()
    except Exception as e:
        QtWidgets.QMessageBox.warning(None, tr("Error"), str(e))
    finally:
        progress_dialog.close()


# --- Main code ---
dialog = InstallationDialog()
if dialog.exec() == QDialog.Accepted:
    mod_path = Path(App.getUserAppDataDir()) / "Mod" / "FCUpdate"
    mod_path.mkdir(parents=True, exist_ok=True)

    (mod_path / "InitGui.py").write_text(init_gui_content, encoding='utf-8')
    (mod_path / "FCUpdate.py").write_text(check_update_content, encoding='utf-8')

    if dialog.is_checked():
        if has_internet_connection():
            translations_path = mod_path / "translations"
            translations_path.mkdir(parents=True, exist_ok=True)
            download_translations(translations_path)
        else:
            QtWidgets.QMessageBox.warning(None,
                tr("No Internet connection"),
                tr("Could not download translations because the computer is offline."))

    msg = QMessageBox()
    msg.setIcon(QMessageBox.Information)
    msg.setText(tr("FCUpdate successfully installed."))
    msg.setInformativeText(tr("Please restart FreeCAD for changes to take effect.\nRestart FreeCAD?"))
    msg.setWindowTitle(tr("Restart Required"))
    msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)

    nowButton = msg.button(QMessageBox.Yes)
    nowButton.setText(tr("Now"))
    laterButton = msg.button(QMessageBox.No)
    laterButton.setText(tr("Later"))

    response = msg.exec()
    if response == QMessageBox.Yes:
        args = QtWidgets.QApplication.arguments()[1:]
        if Gui.getMainWindow().close():
            QtCore.QProcess.startDetached(QtWidgets.QApplication.applicationFilePath(), args)
else:
    QtWidgets.QMessageBox.information(None,
        tr("Installation cancelled"),
        tr("No files have been installed."))
